## 동적계획법과 분할정복

### 동적계획법의 정의
>작은 부분문제의 해를 구한 후
>이를 활용해 큰 크기의 부분문제를 해결
>최종적으로 전체 문제를 해결
>상향식 접근법 : 가장 최하위의 해답을 구한 후 상위를 해결

### 분할정복의 정의
>문제를 나눌 수 없을때까지 나누어 각각을 해결. 
>각각을 풀며 다시 합병해 전체 문제를 해결
>상위 해답을 구하기 위해 아래로 내려가며 하위 해답 구하기

### 동적계획법과 메모이제이션
피보나치 수열을 예로 들면 피보나치 수열을 재귀호출하기 위해서는 
n = 1일 때와 n = 2일 때의 값이 상당히 자주 사용된다. 
따라서 이를 미리 저장해 둔다면 n = 1일 때와 n = 2일 때 재귀호출을
하지 않아도 되기 때문에 빠른 코드를 만들 수 있다. 

#### 일반 재귀코드
```python
def fivo(n) :
    if n == 1 or n == 2 :
        return 1
    else :
        return fivo(n-1) + fivo(n-2)

print(fivo(4))
``` 

#### 동적계획법을 활용한 피보나치 수열
미리 저장된 두 캐시값을 활용해 다음 캐시를 저장하고
저장된 캐시값을 반복문이 끝날때까지 활용해 최종 캐시값을 구한다. 
```python
def fivo_dp(num) :
    cache = [0 for _ in range(num+1)]
    cache[0] = 0
    cache[1] = 1

    for i in range(2, num+1) :
        cache[i] = cache[i-1] + cache[i-2]

    return cache[-1]

print(fivo_dp(10))
```

### 퀵정렬을 통해 살펴보는 분할정복
1. 피벗을 설정한다.(제일 앞에꺼 골라도 되고 아무거나 골라도 됨)
2. 피벗을 기준으로 나머지 데이터들을 피벗보다 큰 데이터와 작은 데이터로 나눈다. 
3. 피벗보다 작으면 피벗 왼쪽, 크면 피벗 오른쪽으로 보낸다. 
4. 정렬이 될때까지 반복한다. 

```python
def qsort(lst) :
    if len(lst) <= 1 :
        return lst
    
    pivot = lst[0]
    left = [i for i in lst[1:] if i <= pivot]
    right = [i for i in lst[1:] if i > pivot]

    return qsort(left) + [pivot] + qsort(right)
```
> 1. 처음 리스트에서 왼쪽과 오른쪽을 분할하면
> 2. 재귀호출에 의해 그 왼쪽과 오른쪽을 분할한다. 
> 3. 그렇게 분할된 리스트 조각들의 길이가 1개 이하면 그것이 부분의 해가 된다. 
> 4. 그 결과들을 전부 모아주면 최종 정렬이 이뤄진다. 