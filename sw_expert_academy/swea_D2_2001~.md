### D2 2001 ~ 

## 2001. 파리퇴치
```python
T = int(input())
for t in range(1, 1+T) : 
    N, M = map(int, input().split())
    lst = [list(map(int, input().split())) for _ in range(N)]
    result = 0
    for i in range(N-M+1) :     # 가로로 파리채가 지나갈 수 있는 경우의 수
        for j in range(N-M+1) :    # 세로로 파리채가 지나갈 수 있는 경우의 수 
            sum_f = 0
            for r in range(i, i+M) : # 파리채의 가로
                for c in range(j, j+M) : # 파리채의 세로
                    sum_f += lst[r][c]   # 해당 칸의 파리를 모두 더해준다
            if sum_f > result : 
                result = sum_f
                
    print('#{} {}'.format(t, result))
```

> 반복문을 물고 뜯으면서 다중 반복문이 돌아가는 원리에 대해 느낀 점이 많았던 문제이다.
>
> - 우선 (가로 * 세로)를 통해 정사각형 파리채가 지나갈 수 있는 총 경우의 수를 2중 for문으로 만든다. 
> - 예를 들어 N이 5이고 M이 3이라면 3짜리 파리채가 지나갈 수 있는 경우의 수는 9개다. 
> - 파리를 몇마리 잡았는가 담기 위한 객체를 하나 만들어 준다. 
> - 파리채가 움직일 수 있는 범위는 가로와 세로 모두 (N-M+1)를 초과할 수 없고 파리채의 크기보다 커서는 안되기 때문에 해당 범위에서만 놀 수 있도록 for문을 짜주어야 한다. 
> - 필요한 값은 최대값만 있으면 되기 때문에 if문을 통해 자동 최신화를 실시한다. 


### 1976 시각덧셈

> 함수 정의 후 리스트로 들어오는 입력값에 대한 답이 출력되게 했음

```python
def timecal(lst) : 
    a, b = 0, 0
    if lst[0] + lst[2] <= 12 : 
        a = lst[0] + lst[2]
    else : 
        a = lst[0] + lst[2] - 12
    if lst[1] + lst[3] < 60 : 
        b = lst[1] + lst[3]
    else : 
        b = lst[1] + lst[3] - 60
        a += 1
    
    return str(a), str(b)

T = int(input())
for t in range(1, 1+T) : 
    lst = list(map(int, input().split()))
    print('#{} {}'.format(t,' '.join(timecal(lst))))
```



### 1946 간단한 압축 풀기

>  출력컨트롤 연습하기 괜찮은 문제

```python
T = int(input())
for t in range(1, 1+T) : 
    a = int(input())
    lst = []
    for i in range(1, a+1) : 
        alphabet, times = input().split()
        for time in range(int(times)) : 
            lst.append(alphabet)
    cnt = 0
    print('#%s'%t)
    for s in lst : 
        print(s, end = '')
        cnt += 1
        if cnt == 10 :      # 10개 넘어가면 개행 추가
            print()
            cnt = 0
    print()          # 에러 방지용 빈 줄 하나 추가
```



### 1970. 쉬운 거스름돈

```python
# 거스름돈 반환하는 함수부터 정의
def change(m) : 
    lst = [0,0,0,0,0,0,0,0]
    if m >= 50000 : 
        lst[0] = m // 50000
        m -= 50000 * lst[0]
    if m >= 10000 : 
        lst[1] = m // 10000
        m -= 10000 * lst[1]
    if m >= 5000 : 
        lst[2] = m // 5000
        m -= 5000 * lst[2]
    if m >= 1000 : 
        lst[3] = m // 1000
        m -= 1000 * lst[3]
    if m>= 500 : 
        lst[4] = m // 500
        m -= 500 * lst[4]
    if m>= 100 : 
        lst[5] = m // 100
        m -= 100 * lst[5]
    if m>= 50 : 
        lst[6] = m // 50
        m -= 50 * lst[6]
    if m>= 10 : 
        lst[7] = m // 10
        m -= 10 * lst[7]
    return lst

# 함수 넣고 출력하면 끝
T = int(input())
for t in range(1, 1+T) : 
    m = int(input())
    s = [str(num) for num in change(m)]  # 조인 때릴라면 문자열이여야 하기 때문
    print('#{}'.format(t))
    print(' '.join(s))
```



### 1959. 두 개의 숫자열

```python
T = int(input())
for t in range(1, 1+T) :
    N, M = map(int, input().split())
    lst_N = list(map(int, input().split()))
    lst_M = list(map(int, input().split()))
    if N < M :
        result = 0
        for i in range(M-N+1) :
            c = 0  # 옮기는 부분의 인덱스는 반복되기 때문
            num = 0
            for j in range(i, i+N) :    
                num += lst_N[c] * lst_M[j]
                c += 1  
            if result < num :
                result = num
                
    else :           # N과 M이 같은 경우도 물론 있지만 문제에서 안물어보니까 생략
        result = 0
        for i in range(N-M+1) :
            c = 0
            num = 0
            for j in range(i, i+M) :
                num += lst_M[c] * lst_N[j]
                c += 1
            if result < num :
                result = num

    print('#{} {}'.format(t, result))
```



### 1974. 스도쿠 검증

```python
def sdoku_hor(lst) :
    '''
    lst: 9 * 9 크기의 스도쿠 2차원 리스트를 인자로 활용합니다.
    return: 스도쿠의 가로 9줄 모두가 1 ~ 9를 포함하면
            True를 반환하고 한줄이라도 1 ~ 9를 모두 포함하지 않으면
            False를 반환합니다.
    '''
    cnt = 0
    for i in range(9) :
        box = []
        for j in range(9) :
            box.append(lst[i][j])
        if set(box) == set(range(1,10)) :
            cnt += 1
    if cnt == 9 :
        return True
    else :
        return False

def sdoku_ver(lst) :
    '''
    lst: 9 * 9 크기의 스도쿠 2차원 리스트를 인자로 활용합니다.
    return: 스도쿠의 세로 9줄 모두가 1 ~ 9를 포함하면
            True를 반환하고 한줄이라도 1 ~ 9를 모두 포함하지 않으면
            False를 반환합니다.
    '''
    cnt = 0
    for i in range(9) :
        box = []
        for j in range(9) :
            box.append(lst[j][i])
        if set(box) == set(range(1,10)) :
            cnt += 1
    if cnt == 9 :
        return True
    else :
        return False

def sdoku_sqr(lst) :
    '''
    lst: 9 * 9 크기의 스도쿠 2차원 리스트를 인자로 활용합니다.
    return: 스도쿠 안의 3*3 사각형 9개 모두가 1 ~ 9를 포함한다면
            True를 반환하고 사각형 1개라도 1 ~ 9를 모두 포함하지 않으면
            False를 반환합니다.
    '''
    cnt = 0
    for i in [0,3,6] :
        for j in [0,3,6] :
            ssum = 0
            for k in range(i, i+3) :
                for c in range(j, j+3) :
                    ssum += lst[k][c]
            if ssum == 45 :
                cnt += 1
    if cnt == 9 :
        return True
    else :
        return False

T = int(input())
for t in range(1, 1+T) :
    lst = [list(map(int,input().split())) for _ in range(9)]
    if sdoku_ver(lst) and sdoku_hor(lst) and sdoku_sqr(lst) :
        print('#{} {}'.format(t, 1))
    else :
        print('#{} {}'.format(t, 0))
```



### 1979. 어디에 단어가 들어갈 수 있을까

```python	
T = int(input())
for t in range(1, 1+T) :
    N, K = map(int, input().split())
    lst = [[0 for _ in range(N+1)]] + [[0] + list(map(int, input().split())) for _ in range(N)]
    cnt = 0
    for i in range(1, N+1) :
        for j in range(1, N+1) :
            if lst[i][j] == 1 :
                if lst[i][j-1] == 0 :      # 가로 탐색 알고리즘
                    n = 1
                    nj = j + 1
                    '''
                    인덱스 끝번호 넘어가지 않게 범위 설정 !!!
                    '''
                    while 1 <= nj < N+1 :       
                        if lst[i][nj] == 0 :
                            break
                        if lst[i][nj] == 1 :
                            n += 1
                        nj += 1
                    if n == K :
                        cnt += 1

                if lst[i-1][j] == 0 :      # 세로 탐색 알고리즘
                    m = 1
                    mi = i + 1
                    while 1 <= mi < N+1 :
                        if lst[mi][j] == 0 :
                            break
                        if lst[mi][j] == 1 :
                            m += 1
                        mi += 1
                    if m == K :
                        cnt += 1

    print('#{} {}'.format(t, cnt))
```

