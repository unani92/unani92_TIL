## 알고리즘 수업 1일차

### 무엇이 좋은 알고리즘인가?

>- 정확성 : 얼마나 정확히 동작하느냐
>- 작업량 : 얼마나 적은 연산으로 결과가 나오는가
>- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
>- 단순성 : 얼마나 단순한가
>- 최적성 : 더이상 개선의 여지 없이 최적화되어 있는가
>
> 


### 알고리즘의 성능을 평가하다.

> #### 시간복잡도 
>
> - 빅오 표기법 : 충분히 큰 n에 대하여 **가장 큰 영향력을 주는 n**에 대한 항 만을 남기는 표기법
>   - O(3n+2) = O(3n) = O(n)
>   - O(3n^2+2n+1) = O(3n^2) = O(n^2)
>
> <img src="https://user-images.githubusercontent.com/53211781/73412565-558b7600-434c-11ea-9c6c-c3602d0a193a.png" alt="image" style="zoom:80%;" />
>
> <img src="https://user-images.githubusercontent.com/53211781/73412565-558b7600-434c-11ea-9c6c-c3602d0a193a.png" alt="image" style="zoom:80%;" />



### 배열이란 무엇인가

> 일정한 자료형의 변수들을 하나의 이름으로 열거해 사용하는 자료구조
>
> ```python
> num = [0,1,2,3,4,5]
> ```
>
> #### 왜 필요한가
>
> - 일일히 다른 변수명을 이용해 자료에 접근하기 비효율적이기 때문
> - 선언 하나에 둘 이상의 변수를 선언할 수 있다. 



### 디버거 사용하기

> 디버깅 :  **에러가 없는 상황**에서 의도한대로 돌아가는 지 확인하는 과정
>
> #### 개발툴을 사용하는 이유 
>
> - 에러 시 에러메시지를 확인할 수 있다. 
> - 디버깅을 할 수 있다. 
>
> 
>
> #### 디버깅 기능
>
> - breakpoint 설정 : 해당 지점에서 실행을 잠시 멈추고 대기!!
>
> - step over :  한줄씩 넘어가는 기능, 함수 자체도 한 줄로 인식하고 통으로 실행
> - step into : 한줄씩 넘어가는 기능은 같지만 세부적으로 사용자내부 함수가 있을 시 함수 내부로 진입



### 완전검색

> 생각할 수 있는 **모든 경우의 수를 나열하고 확인**하는 기법. A형은 이것만 할줄 알아도 왠만큼 해결됨. 경우의수가 많으면 시간문제에 걸릴 수 있음. 주어진 문제를 해결할 때 우선 완전검색으로 접근하고 실행이 된다면, 성능개선을 위해 효율적 방식으로 고칠 수 있다. 
예) for문 중첩의 중첩을 통한 순열 알고리즘

### 탐욕(greedy) 알고리즘

> 선택하는 그 순간에 최적이라 생각되는 것을 선택해 나가는 방식으로 진행. 당장의 시점에서 보면 최적이겠지만 **최종적인 최적 선택이라는 보장은 없음.**
예) 거스름돈 줄이기 
```python
# 자리수 개수 추출 알고리즘

arr = list(input())
count = [0] * 10 
for i in range(6) : 
    count[int(arr[i])] += 1
    print(count)
```

### 버블소팅
> 시간복잡도 : O(n^2)
- 우선 한쪽 방향을 기준으로 잡는데 간단하게 왼쪽을 기준으로 한다. 
- 첫 구간은 0 ~ n-1까지
- 두개를 잡고 큰놈을 오른쪽으로 보낸다.
- 다음 구간은 0 ~ n-2이고 끝날때까지 반복한다.
<img src="https://user-images.githubusercontent.com/53211781/73422613-e4a88600-436c-11ea-9f68-2b15101e3e4d.png" alt="image" style="zoom:80%;" />

```python
def bubbleSort(a) : 
    for i in range(len(a)-1,0,-1) : 
        for j in range(0,i) : 
            if a[j] > a[j+1] : 
                a[j], a[j+1] = a[j+1], a[j]
```

### 카운팅 정렬
> 예를 들어 5보다 작은 원소가 4개 있을 때 5는 5번째에 배치하면 된다는 원리
> 시간복잡도는 O(n+k)
>
> 1. 정렬될 리스트가 있으면 리스트 원소들의 개수를 먼저 세준다.
 - [0,4,1,3,1,2,4,1] -> {0:1, 1:3, 2:1, 3:1, 4:1}
 2.  제일 오른쪽부터 temp에 넣어준다. 
 ```
 lst ->  0 4 1 3 1 2 4 '1'
 temp ->       1
 ```
 3. 오른쪽에서 왼쪽으로 이동하면서 해당 숫자들을 자리에 넣어준다. 
 ```
 lst ->  0 4 1 3 1 2 '4' 
 temp ->       1         4
 lst ->  0 4 1 3  1 '2'  
 temp ->       1  2       4
 ```
 4. 끝날때까지 반복하면 정렬이 완성된다. 
 ```
 lst -> '0'   
 temp -> 0 1 1 1 2 3 4 4
 ```

### 번외 : 점점 커지는 당근의 개수
> 숫자들이 들어있는 리스트에서 연속으로 커지는 갯수는 **최대** 몇개인지 구하는 문제였는데 함정에서 20분동안 헤메고 있어서 박제해놓으려고 한다. 

```python
T = int(input())
for t in range(1, 1+T) : 
    N = int(input())
    lst = list(map(int, input().split()))
    cnt = 1
    result = 1
    for i in range(N-1) :
        if lst[i] < lst[1+i] :
           cnt += 1
    
           if cnt > result :
               result = cnt
    
        else :
            cnt = 1
    
    print('#{} {}'.format(t, result))
```
> 비교적 간단한 문제였으나 리스트를 전부 순회하면서 최대값을 구하는 것을 놓치는 바람에 삽질을 좀 했었다. 

##### 오답코드
```python
def carrot_counter(lst) :
    cnt = 1
    for i in range(len(lst)-1) :
        if lst[i] < lst[i+1] :
            cnt += 1
        else :
            cnt = 1

    return cnt

T = int(input())
for t in range(1, 1+T) :
    N = int(input())
    lst = list(map(int, input().split()))
    print('#{} {}'.format(t, carrot_counter(lst)))
```
> 이렇게 짜면 작아지는 구간을 마주할 때 0으로 초기화되는 문제가 발생한다. 그러면 앞부분에서 최대값이 나와도 이를 반영할 수 없으니 틀린 값이 나온다. 앞으로 조심하고 문제 똑바로 읽읍시다....
